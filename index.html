<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Crumb Chase â€” Mouse vs Cat</title>
    <style>
      :root {
        --bg1: #10131a;
        --bg2: #0b1222;
        --ink: #e9f1ff;
        --accent: #7aa2ff;
        --crumb: #ffdf7e;
        --crumb2: #ffcc66;
        --mouse: #b8c0cc; /* grey */
        --cat: #ff69b4; /* hot pink */
        --hole: #0a0a0a;
        --ui: rgba(255, 255, 255, 0.08);
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        display: grid;
        place-items: center;
        background: radial-gradient(
          1000px 800px at 70% 30%,
          #1a2236,
          #0c1020 60%,
          #060813 100%
        );
        color: var(--ink);
        font: 500 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto,
          "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji",
          "Segoe UI Emoji";
        user-select: none;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      canvas {
        display: block;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          rgba(255, 255, 255, 0)
        );
      }

      /* HUD layout (centered, no overlap) */
      .hud-top {
        display: block;
        position: static;
        margin: 0 auto 10px;
        width: auto;
        max-width: calc(100% - 24px);
        background: var(--ui);
        backdrop-filter: blur(6px);
        padding: 8px 16px;
        border-radius: 12px;
        box-shadow: 0 1px 0 rgba(255, 255, 255, 0.06) inset,
          0 0 0 1px rgba(255, 255, 255, 0.06) inset;
        pointer-events: none;
        text-align: center;
      }
      .hud-bottom {
        display: block;
        position: static;
        margin: 10px auto 0;
        width: auto;
        max-width: calc(100% - 24px);
        background: var(--ui);
        backdrop-filter: blur(6px);
        padding: 8px 16px;
        border-radius: 12px;
        box-shadow: 0 1px 0 rgba(255, 255, 255, 0.06) inset,
          0 0 0 1px rgba(255, 255, 255, 0.06) inset;
        text-align: center;
        pointer-events: none;
      }
      .hud .row {
        display: flex;
        gap: 10px;
        align-items: center;
        margin-top: 4px;
        text-align: center;
        justify-content: center;
      }
      .btn {
        appearance: none;
        border: 0;
        border-radius: 10px;
        padding: 8px 10px;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.12);
        color: var(--ink);
        font-weight: 600;
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.08) inset;
        transition: transform 0.08s ease, background 0.2s ease;
      }
      .btn:hover {
        background: rgba(255, 255, 255, 0.18);
      }
      .btn:active {
        transform: translateY(1px);
      }

      /* Let clicks pass through HUD except buttons */
      .hud .btn {
        pointer-events: auto;
      }

      .toast {
        position: absolute;
        inset: auto 0 22px 0;
        margin-inline: auto;
        width: fit-content;
        z-index: 2;
        background: rgba(0, 0, 0, 0.45);
        color: #eaf1ff;
        padding: 10px 14px;
        border-radius: 999px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        display: block;
        pointer-events: none;
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: none;
        place-items: center;
        z-index: 3;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0),
          rgba(0, 0, 0, 0.25)
        );
      }
      .card {
        background: rgba(20, 24, 38, 0.95);
        border-radius: 16px;
        padding: 14px 16px;
        box-shadow: 0 12px 50px rgba(0, 0, 0, 0.4);
        border: 1px solid rgba(255, 255, 255, 0.06);
        max-width: min(80vw, 520px);
      }
      .card h1 {
        font-size: 22px;
        margin: 0 0 10px;
      }
      .card p {
        opacity: 0.9;
        margin: 8px 0;
      }
      .card code {
        background: rgba(255, 255, 255, 0.08);
        padding: 2px 6px;
        border-radius: 6px;
      }
      .card .actions {
        display: flex;
        gap: 10px;
        margin-top: 14px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="hud hud-top" id="hudTop">
        <b style="color: var(--accent)">Crumb Chase</b> â€” reach the hole without
        getting caught.
      </div>
      <canvas
        id="game"
        width="800"
        height="540"
        aria-label="Crumb Chase game"
        tabindex="0"
      ></canvas>

      <div class="hud hud-bottom" id="hud">
        <div class="row">
          <span id="stats"></span>
          <button class="btn" id="resetBtn">Restart</button>
        </div>
        <div class="row">
          <span>
            Controls: Tap <code>Arrows</code> or click to steer.
            <code>Space</code> = stop. <code>R</code> = restart.
          </span>
          <span id="copyright">Â© Dmitriy Vasilyuk, 1993 &amp; 2025</span>
        </div>
      </div>
      <div class="toast" id="toast"></div>
      <div class="overlay" id="overlay">
        <div class="card" id="overlayCard">
          <h1 id="ovTitle">You win!</h1>
          <p id="ovMsg">Nice work.</p>
          <div class="actions">
            <button class="btn" id="playAgain">Play again</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        "use strict";
        const DEBUG = false; // Run sanity checks
        // ====== TUNABLES / SIZING ======
        const TILE = 20; // pixels per grid cell (twice as big)
        const COLS = 40; // grid width  -> canvas width = 800
        const ROWS = 25; // grid height -> canvas height = 540

        const PLAYER_SPEED_CELLS = 6.0; // mouse speed (cells/sec)
        const CAT_BASE_SPEED_CELLS = 3.2; // cat base speed (slower than mouse)
        const CAT_SPEED_IN_CRUMB = 0.25; // 4x slower inside crumbs (noticeably slower)
        const CRUMB_DECAY_PER_SEC = 12.0; // random crumb removal attempts per second (avg)
        const A_STAR_RECALC_HZ = 5; // how often each cat replans per second
        const CRUMB_COST_FOR_CAT = 14; // pathfinding cost for crumb tiles (vs 1 open)
        const TURN_EPS = TILE * 0.35; // tolerance to commit turns at cell center

        // Crumb physics
        const CRUMB_STRENGTH = 1; // thickness for trail crumbs
        const RING_CRUMB_STRENGTH = 1; // thicker barrier around the hole
        const CAT_EAT_RATE = 1.0; // crumb thickness removed per second by a cat
        const PROB_BIASED_RING_DECAY = 0;

        // Cat divergence
        const GOAL_JITTER_RANGE = 1; // Â±cells added to cat goal to avoid perfect overlap
        const NOISE_REFRESH_MIN = 0.8; // seconds
        const NOISE_REFRESH_MAX = 1.6; // seconds
        const SEPARATION_RADIUS_CELLS = 3.0; // start repelling within this many cells
        const SEPARATION_FORCE = 40; // px/sec of steering when overlapping

        const DPR = Math.max(1, window.devicePixelRatio || 1);

        // Level config (1..10)
        // Max cats = 3. Speed is a multiple of player speed (e.g. 0.5 = half of mouse)
        const LEVEL_CONFIG = [
          null,
          { cats: 1, speedFactor: 0.55 },
          { cats: 1, speedFactor: 0.9 },
          { cats: 2, speedFactor: 0.55 },
          { cats: 2, speedFactor: 0.9 },
          { cats: 2, speedFactor: 1.2 },
          { cats: 3, speedFactor: 0.75 },
          { cats: 3, speedFactor: 1.0 },
          { cats: 3, speedFactor: 1.25 },
          { cats: 3, speedFactor: 1.5 },
          { cats: 4, speedFactor: 1.2 },
        ];

        function getLevelConfig(L) {
          const i = Math.max(1, Math.min(10, L));
          return LEVEL_CONFIG[i];
        }

        // ====== CANVAS ======
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        // Scale for HiDPI crispness
        canvas.width = COLS * TILE * DPR;
        canvas.height = ROWS * TILE * DPR;
        canvas.style.width = COLS * TILE + "px";
        canvas.style.height = ROWS * TILE + "px";
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

        const hudStats = document.getElementById("stats");
        const overlay = document.getElementById("overlay");
        const ovTitle = document.getElementById("ovTitle");
        const ovMsg = document.getElementById("ovMsg");
        const playAgain = document.getElementById("playAgain");
        const resetBtn = document.getElementById("resetBtn");
        const toast = document.getElementById("toast");

        // ====== WORLD STATE ======
        const N = COLS * ROWS;
        const crumbs = new Float32Array(N); // thickness (0 = empty)
        const ringSet = new Set(); // crumb cells forming the hole's barrier (for biased decay)
        const holeOpenSet = new Set(); // cells that count as the open hole (win zone)

        // Wider hole ON the left edge (taller opening)
        const hole = { c: 0, r: Math.floor(ROWS * 0.5), halfHeight: 2 }; // vertical opening height = 2*halfHeight+1

        const player = {
          x: (COLS - 5 + 0.5) * TILE,
          y: (ROWS * 0.5 + 0.5) * TILE,
          r: TILE * 0.76, // schematic mouse head
          speed: PLAYER_SPEED_CELLS * TILE,
          color: getCSS("--mouse"),
          lastCell: { c: -1, r: -1 },
        };

        // Multiple cats (level-scaled)
        let cats = [];
        let level = 1;
        let prevCatCount = 0;

        // Latched movement direction for the player
        let dirX = 0,
          dirY = 0; // -1,0,1 each
        let wishX = 0,
          wishY = 0; // desired direction
        let wishTimer = 0;

        const keys = Object.create(null); // keep for debug (Shift)
        let running = true;
        let timeAlive = 0;
        let decayAccum = 0;

        // ====== HELPERS ======
        function getCSS(name) {
          return getComputedStyle(document.documentElement)
            .getPropertyValue(name)
            .trim();
        }
        function idx(c, r) {
          return r * COLS + c;
        }
        function inBounds(c, r) {
          return c >= 0 && r >= 0 && c < COLS && r < ROWS;
        }
        function cellAt(x, y) {
          return { c: Math.floor(x / TILE), r: Math.floor(y / TILE) };
        }
        function centerOf(c, r) {
          return { x: (c + 0.5) * TILE, y: (r + 0.5) * TILE };
        }
        // Helpers for robust turn commits (allow current or next center)
        function nearestColumnCenter(x, movingDirX) {
          const c = Math.floor(x / TILE);
          const cx0 = (c + 0.5) * TILE;
          if (movingDirX !== 0) {
            const cx1 = (c + 0.5 + Math.sign(movingDirX)) * TILE;
            return Math.abs(x - cx0) < Math.abs(x - cx1) ? cx0 : cx1;
          }
          return cx0;
        }
        function canTurnVertical(x, movingDirX) {
          const c = Math.floor(x / TILE);
          const cx0 = (c + 0.5) * TILE;
          if (Math.abs(x - cx0) <= TURN_EPS) return true;
          if (movingDirX !== 0) {
            const cx1 = (c + 0.5 + Math.sign(movingDirX)) * TILE;
            if (Math.abs(x - cx1) <= TURN_EPS) return true;
          }
          return false;
        }
        function nearestRowCenter(y, movingDirY) {
          const r = Math.floor(y / TILE);
          const cy0 = (r + 0.5) * TILE;
          if (movingDirY !== 0) {
            const cy1 = (r + 0.5 + Math.sign(movingDirY)) * TILE;
            return Math.abs(y - cy0) < Math.abs(y - cy1) ? cy0 : cy1;
          }
          return cy0;
        }
        function canTurnHorizontal(y, movingDirY) {
          const r = Math.floor(y / TILE);
          const cy0 = (r + 0.5) * TILE;
          if (Math.abs(y - cy0) <= TURN_EPS) return true;
          if (movingDirY !== 0) {
            const cy1 = (r + 0.5 + Math.sign(movingDirY)) * TILE;
            if (Math.abs(y - cy1) <= TURN_EPS) return true;
          }
          return false;
        }
        function isCrumb(c, r) {
          return inBounds(c, r) ? crumbs[idx(c, r)] > 0 : true;
        } // out of bounds = wall
        function addCrumb(c, r, strength = CRUMB_STRENGTH) {
          if (inBounds(c, r)) {
            const k = idx(c, r);
            crumbs[k] = Math.max(crumbs[k], strength);
          }
        }
        function removeCrumb(c, r) {
          if (inBounds(c, r)) {
            const k = idx(c, r);
            crumbs[k] = 0;
            ringSet.delete(k);
          }
        }
        function weakenCrumb(c, r, amount) {
          if (inBounds(c, r)) {
            const k = idx(c, r);
            if (crumbs[k] > 0) {
              crumbs[k] = Math.max(0, crumbs[k] - amount);
              if (crumbs[k] === 0) ringSet.delete(k);
            }
          }
        }
        function weakenCrumbByIndex(k, amount) {
          if (k >= 0 && k < N) {
            if (crumbs[k] > 0) {
              crumbs[k] = Math.max(0, crumbs[k] - amount);
              if (crumbs[k] === 0) ringSet.delete(k);
            }
          }
        }

        function showToast(msg, ms = 1200) {
          toast.textContent = msg;
          toast.style.display = "block";
          setTimeout(() => {
            toast.style.display = "none";
          }, ms);
        }

        // Noticeable speed ramp; still capped below mouse speed

        function randInt(a, b) {
          return ((Math.random() * (b - a + 1)) | 0) + a;
        }
        function randRange(a, b) {
          return a + Math.random() * (b - a);
        }

        function makeCat(colFrac, rowFrac, speedCells, id) {
          const x =
            (Math.max(0, Math.min(COLS - 1, Math.round(COLS * colFrac))) +
              0.5) *
            TILE;
          const y =
            (Math.max(0, Math.min(ROWS - 1, Math.round(ROWS * rowFrac))) +
              0.5) *
            TILE;
          return {
            id,
            x,
            y,
            r: TILE * 0.88, // schematic cat head
            speedCells,
            color: getCSS("--cat"),
            path: [],
            pathTimer: 0,
            goalJitter: {
              dc: randInt(-GOAL_JITTER_RANGE, GOAL_JITTER_RANGE),
              dr: randInt(-GOAL_JITTER_RANGE, GOAL_JITTER_RANGE),
            },
            noiseTimer: randRange(NOISE_REFRESH_MIN, NOISE_REFRESH_MAX),
          };
        }

        function buildHoleBarrier() {
          ringSet.clear();
          holeOpenSet.clear();
          const rmin = Math.max(0, hole.r - hole.halfHeight);
          const rmax = Math.min(ROWS - 1, hole.r + hole.halfHeight);
          // Mark open hole cells along the LEFT EDGE at c=0
          for (let r = rmin; r <= rmax; r++) holeOpenSet.add(idx(0, r));

          // Surround that opening with a THICK rectangular crumb barrier
          for (let c = 0; c <= 2; c++) {
            for (let r = rmin - 1; r <= rmax + 1; r++) {
              if (!inBounds(c, r)) continue;
              if (c === 0 && r >= rmin && r <= rmax) continue; // leave the actual hole empty
              addCrumb(c, r, RING_CRUMB_STRENGTH);
              ringSet.add(idx(c, r));
            }
          }
          // Extra top/bottom caps (harder to slip around)
          for (let c = 0; c <= 1; c++) {
            for (let r = rmin - 2; r <= rmin - 1; r++) {
              if (inBounds(c, r)) {
                addCrumb(c, r, RING_CRUMB_STRENGTH);
                ringSet.add(idx(c, r));
              }
            }
            for (let r = rmax + 1; r <= rmax + 2; r++) {
              if (inBounds(c, r)) {
                addCrumb(c, r, RING_CRUMB_STRENGTH);
                ringSet.add(idx(c, r));
              }
            }
          }
        }

        function resetAll() {
          startLevel(true);
        }

        function startLevel(resetLevelNumber = false) {
          if (resetLevelNumber) {
            level = 1;
            prevCatCount = 0;
          }

          crumbs.fill(0);
          ringSet.clear();
          holeOpenSet.clear();
          player.x = (COLS - 5 + 0.5) * TILE;
          player.y = (ROWS * 0.5 + 0.5) * TILE;
          player.lastCell = { c: -1, r: -1 };

          const { cats: targetCats, speedFactor } = getLevelConfig(level);
          const speedCells = PLAYER_SPEED_CELLS * speedFactor;

          cats = [];
          const spawnGrid = [
            [0.35, 0.25],
            [0.35, 0.75],
            [0.65, 0.25],
            [0.65, 0.75],
            [0.5, 0.5],
          ];
          for (let i = 0; i < targetCats; i++) {
            const p = spawnGrid[i % spawnGrid.length];
            cats.push(makeCat(p[0], p[1], speedCells, i));
          }
          prevCatCount = targetCats;

          overlay.style.display = "none";
          timeAlive = 0;
          decayAccum = 0;
          running = true;
          buildHoleBarrier();
          draw(0);
          showToast(`Level ${level} â€” Cats: ${cats.length}`);
          // Auto-focus so arrows work immediately
          setTimeout(() => canvas.focus(), 0);
        }

        // ====== PATHFINDING (A*) ======
        function aStar(startC, startR, goalC, goalR) {
          const start = idx(startC, startR),
            goal = idx(goalC, goalR);
          if (start === goal) return [];

          const g = new Float32Array(N);
          const f = new Float32Array(N);
          const came = new Int32Array(N);
          const closed = new Uint8Array(N);
          for (let i = 0; i < N; i++) {
            g[i] = Infinity;
            f[i] = Infinity;
            came[i] = -1;
          }

          const open = new Uint8Array(N);
          g[start] = 0;
          f[start] = heuristic(startC, startR, goalC, goalR);
          open[start] = 1;

          while (true) {
            let current = -1;
            let bestF = Infinity;
            for (let i = 0; i < N; i++) {
              if (open[i] && f[i] < bestF) {
                bestF = f[i];
                current = i;
              }
            }
            if (current === -1) break; // no path
            open[current] = 0;
            closed[current] = 1;
            if (current === goal) break; // found

            const curC = current % COLS;
            const curR = (current / COLS) | 0;
            const neigh = [
              [1, 0],
              [-1, 0],
              [0, 1],
              [0, -1],
            ];
            for (let k = 0; k < 4; k++) {
              const nc = curC + neigh[k][0];
              const nr = curR + neigh[k][1];
              if (!inBounds(nc, nr)) continue;
              const ni = idx(nc, nr);
              if (closed[ni]) continue;
              const stepCost = isCrumb(nc, nr) ? CRUMB_COST_FOR_CAT : 1;
              const tentative = g[current] + stepCost;
              if (tentative < g[ni]) {
                came[ni] = current;
                g[ni] = tentative;
                f[ni] = tentative + heuristic(nc, nr, goalC, goalR);
                open[ni] = 1;
              }
            }
          }

          if (came[goal] === -1) return [];
          const path = [];
          let node = goal;
          while (node !== start && node !== -1) {
            path.push(node);
            node = came[node];
          }
          path.reverse();
          const cells = new Array(path.length);
          for (let i = 0; i < path.length; i++) {
            const p = path[i];
            cells[i] = { c: p % COLS, r: (p / COLS) | 0 };
          }
          return cells;
        }
        function heuristic(c1, r1, c2, r2) {
          return Math.abs(c1 - c2) + Math.abs(r1 - r2);
        }

        // ====== INPUT (latched) ======
        function setDirectionFromKey(key) {
          if (key === "ArrowLeft" || key === "a" || key === "A") {
            wishX = -1;
            wishY = 0;
          } else if (key === "ArrowRight" || key === "d" || key === "D") {
            wishX = 1;
            wishY = 0;
          } else if (key === "ArrowUp" || key === "w" || key === "W") {
            wishX = 0;
            wishY = -1;
          } else if (key === "ArrowDown" || key === "s" || key === "S") {
            wishX = 0;
            wishY = 1;
          }
        }

        window.addEventListener("keydown", (e) => {
          if (
            [
              "ArrowUp",
              "ArrowDown",
              "ArrowLeft",
              "ArrowRight",
              " ",
              "Spacebar",
            ].includes(e.key)
          )
            e.preventDefault();
          if (e.key === "r" || e.key === "R") {
            startLevel(true);
            return;
          }
          if (e.key === " " || e.key === "Spacebar") {
            dirX = 0;
            dirY = 0;
            wishX = 0;
            wishY = 0;
            return;
          }
          setDirectionFromKey(e.key);
          keys[e.key] = true; // for Shift debug
        });
        window.addEventListener("keyup", (e) => {
          keys[e.key] = false;
        });
        canvas.addEventListener("pointerdown", (e) => {
          canvas.focus();
          // Click-to-steer: set latched direction toward click, snapped to cardinal axes
          const rect = canvas.getBoundingClientRect();
          const px =
            ((e.clientX - rect.left) * (canvas.width / rect.width)) / DPR;
          const py =
            ((e.clientY - rect.top) * (canvas.height / rect.height)) / DPR;
          const dx = px - player.x;
          const dy = py - player.y;
          if (Math.abs(dx) > Math.abs(dy)) {
            wishX = Math.sign(dx);
            wishY = 0;
          } else {
            wishX = 0;
            wishY = Math.sign(dy);
          }
        });
        resetBtn.addEventListener("click", () => startLevel(true));
        playAgain.addEventListener("click", () => startLevel(true));

        // ====== UPDATE LOOP ======
        let lastTime = performance.now();
        buildHoleBarrier();
        startLevel(true);
        runSanityTests(); // basic runtime checks; see console
        requestAnimationFrame(loop);

        function loop(ts) {
          const dt = Math.min(0.05, (ts - lastTime) / 1000); // clamp dt to 50ms
          lastTime = ts;
          if (running) update(dt);
          draw(dt);
          requestAnimationFrame(loop);
        }

        function isHoleCell(c, r) {
          return c === 0 && holeOpenSet.has(idx(c, r));
        }

        function update(dt) {
          timeAlive += dt;
          // Commit turns (robust): allow at current OR next center; allow instant start when stopped
          // Track wish age; if it lingers, snap to center and commit so turns never starve.
          if (wishX !== dirX || wishY !== dirY) wishTimer += dt;
          else wishTimer = 0;

          if (
            !(wishX === 0 && wishY === 0) &&
            (wishX !== dirX || wishY !== dirY)
          ) {
            if (wishX === 0 && wishY !== 0) {
              if (dirX === 0 && dirY === 0) {
                player.x = nearestColumnCenter(player.x, 0);
                dirX = 0;
                dirY = Math.sign(wishY);
                wishTimer = 0;
              } else if (canTurnVertical(player.x, dirX)) {
                player.x = nearestColumnCenter(player.x, dirX);
                dirX = 0;
                dirY = Math.sign(wishY);
                wishTimer = 0;
              } else if (wishTimer > 0.25) {
                player.x = nearestColumnCenter(player.x, dirX);
                dirX = 0;
                dirY = Math.sign(wishY);
                wishTimer = 0;
              } // fail-safe snap
            } else if (wishY === 0 && wishX !== 0) {
              if (dirX === 0 && dirY === 0) {
                player.y = nearestRowCenter(player.y, 0);
                dirY = 0;
                dirX = Math.sign(wishX);
                wishTimer = 0;
              } else if (canTurnHorizontal(player.y, dirY)) {
                player.y = nearestRowCenter(player.y, dirY);
                dirY = 0;
                dirX = Math.sign(wishX);
                wishTimer = 0;
              } else if (wishTimer > 0.25) {
                player.y = nearestRowCenter(player.y, dirY);
                dirY = 0;
                dirX = Math.sign(wishX);
                wishTimer = 0;
              } // fail-safe snap
            }
          }
          // Player movement using latched direction
          const prevCell = cellAt(player.x, player.y);
          moveAgent(
            player,
            dirX * player.speed * dt,
            dirY * player.speed * dt,
            /*blockCrumb=*/ true
          );
          // Snap to tile center immediately when stopped to avoid perpendicular-jerk on next move
          if (dirX === 0 && dirY === 0) {
            const ccStop = cellAt(player.x, player.y);
            player.x = (ccStop.c + 0.5) * TILE;
            player.y = (ccStop.r + 0.5) * TILE;
          }
          // Snap to grid centers for consistent alignment when moving strictly vertical/horizontal
          if (dirX === 0 && dirY !== 0) {
            const cc = cellAt(player.x, player.y);
            player.x = (cc.c + 0.5) * TILE;
          } else if (dirY === 0 && dirX !== 0) {
            const cc = cellAt(player.x, player.y);
            player.y = (cc.r + 0.5) * TILE;
          }
          const curCell = cellAt(player.x, player.y);
          if (
            (curCell.c !== prevCell.c || curCell.r !== prevCell.r) &&
            inBounds(prevCell.c, prevCell.r)
          ) {
            if (!isHoleCell(prevCell.c, prevCell.r))
              addCrumb(prevCell.c, prevCell.r, CRUMB_STRENGTH);
          }

          // Win check: reached any hole cell along the left edge
          if (isHoleCell(curCell.c, curCell.r)) {
            level += 1;
            startLevel(false);
            return;
          }

          // Cats AI + movement
          for (let i = 0; i < cats.length; i++) {
            const cat = cats[i];

            // Periodically jitter the cat's goal so multiple cats diverge
            cat.noiseTimer -= dt;
            if (cat.noiseTimer <= 0) {
              cat.goalJitter.dc = randInt(
                -GOAL_JITTER_RANGE,
                GOAL_JITTER_RANGE
              );
              cat.goalJitter.dr = randInt(
                -GOAL_JITTER_RANGE,
                GOAL_JITTER_RANGE
              );
              cat.noiseTimer = randRange(NOISE_REFRESH_MIN, NOISE_REFRESH_MAX);
            }

            cat.pathTimer -= dt;
            if (cat.pathTimer <= 0) {
              const ps = cellAt(player.x, player.y);
              // Apply goal jitter but keep within bounds
              const gc = Math.max(
                0,
                Math.min(COLS - 1, ps.c + cat.goalJitter.dc)
              );
              const gr = Math.max(
                0,
                Math.min(ROWS - 1, ps.r + cat.goalJitter.dr)
              );
              const cs = cellAt(cat.x, cat.y);
              cat.path = aStar(cs.c, cs.r, gc, gr);
              cat.pathTimer = 1 / A_STAR_RECALC_HZ;
            }

            const cs0 = cellAt(cat.x, cat.y);
            let slow = isCrumb(cs0.c, cs0.r);
            if (!slow && cat.path && cat.path.length) {
              const nxt = cat.path[0];
              slow = isCrumb(nxt.c, nxt.r);
            }
            let speedPx =
              cat.speedCells * TILE * (slow ? CAT_SPEED_IN_CRUMB : 1);

            // Separation steering so cats don't stack
            let sepX = 0,
              sepY = 0;
            for (let j = 0; j < cats.length; j++) {
              if (i === j) continue;
              const other = cats[j];
              const dx = cat.x - other.x,
                dy = cat.y - other.y;
              const d = Math.hypot(dx, dy);
              const R = SEPARATION_RADIUS_CELLS * TILE;
              if (d > 0 && d < R) {
                const m = (R - d) / R; // 0..1
                sepX += (dx / d) * m;
                sepY += (dy / d) * m;
              }
            }
            if (sepX !== 0 || sepY !== 0) {
              const sl = Math.hypot(sepX, sepY) || 1;
              cat.x += (sepX / sl) * SEPARATION_FORCE * dt;
              cat.y += (sepY / sl) * SEPARATION_FORCE * dt;
            }

            // Follow path
            if (cat.path && cat.path.length) {
              const next = cat.path[0];
              const target = centerOf(next.c, next.r);
              const dx = target.x - cat.x,
                dy = target.y - cat.y;
              const d = Math.hypot(dx, dy) || 1;
              const step = Math.min(d, speedPx * dt);
              cat.x += (dx / d) * step;
              cat.y += (dy / d) * step;
              if (
                d <= 0.5 ||
                (Math.abs(cat.x - target.x) < 0.5 &&
                  Math.abs(cat.y - target.y) < 0.5)
              ) {
                cat.path.shift();
              }
            } else {
              // Fallback: steer directly with a tiny bit of noise
              const dx = player.x + randRange(-0.2, 0.2) * TILE - cat.x;
              const dy = player.y + randRange(-0.2, 0.2) * TILE - cat.y;
              const d = Math.hypot(dx, dy) || 1;
              const step = speedPx * dt;
              cat.x += (dx / d) * step;
              cat.y += (dy / d) * step;
            }

            // Eat crumbs
            const cs1 = cellAt(cat.x, cat.y);
            if (isCrumb(cs1.c, cs1.r))
              weakenCrumb(cs1.c, cs1.r, CAT_EAT_RATE * dt);

            // Catch check (any cat)
            const dist = Math.hypot(cat.x - player.x, cat.y - player.y);
            if (dist < (cat.r + player.r) * 0.75) {
              running = false;
              ovTitle.textContent = "Caught! ðŸ±";
              ovMsg.textContent = `Level ${level}, survived ${timeAlive.toFixed(
                1
              )}s.`;
              overlay.style.display = "grid";
              return;
            }
          }

          // Random crumb decay
          decayAccum += dt * CRUMB_DECAY_PER_SEC;
          while (decayAccum >= 1) {
            decayAccum -= 1;
            decayOneCrumb();
          }

          // HUD stats
          if (((timeAlive * 10) | 0) % 2 === 0) {
            const crumbCount = countCrumbs();
            const sp = cats.length ? cats[0].speedCells : 0;
            hudStats.textContent = `Level ${level} Â· Time: ${timeAlive.toFixed(
              0
            )}s Â· Crumbs: ${crumbCount} Â· Cat speed: ${sp.toFixed(2)}c/s`;
          }
        }

        function moveAgent(agent, dx, dy, blockCrumb) {
          const EPS = 1e-6;
          // Horizontal movement: if next tile is blocked, do not pass the center of the current tile
          if (dx !== 0) {
            const cc = cellAt(agent.x, agent.y);
            const centerX = (cc.c + 0.5) * TILE;
            const dir = Math.sign(dx);
            const nextC = cc.c + dir;
            const nextBlocked =
              blockCrumb && (!inBounds(nextC, cc.r) || isCrumb(nextC, cc.r));
            let nx = agent.x + dx;
            if (nextBlocked) {
              nx = dir > 0 ? Math.min(nx, centerX) : Math.max(nx, centerX);
            }
            const cell = cellAt(nx, agent.y);
            if (
              !(blockCrumb && isCrumb(cell.c, cell.r)) &&
              inBounds(cell.c, cell.r)
            )
              agent.x = nx;
            // If we were clamped to the center, snap exactly to the center to avoid later "jerk"
            if (
              nextBlocked &&
              ((dir > 0 && agent.x >= centerX - EPS) ||
                (dir < 0 && agent.x <= centerX + EPS))
            ) {
              agent.x = centerX;
            }
          }

          // Vertical movement: if next tile is blocked, do not pass the center of the current tile
          if (dy !== 0) {
            const cc = cellAt(agent.x, agent.y);
            const centerY = (cc.r + 0.5) * TILE;
            const dir = Math.sign(dy);
            const nextR = cc.r + dir;
            const nextBlocked =
              blockCrumb && (!inBounds(cc.c, nextR) || isCrumb(cc.c, nextR));
            let ny = agent.y + dy;
            if (nextBlocked) {
              ny = dir > 0 ? Math.min(ny, centerY) : Math.max(ny, centerY);
            }
            const cell = cellAt(agent.x, ny);
            if (
              !(blockCrumb && isCrumb(cell.c, cell.r)) &&
              inBounds(cell.c, cell.r)
            )
              agent.y = ny;
            // If we were clamped to the center, snap exactly to the center to avoid later "jerk"
            if (
              nextBlocked &&
              ((dir > 0 && agent.y >= centerY - EPS) ||
                (dir < 0 && agent.y <= centerY + EPS))
            ) {
              agent.y = centerY;
            }
          }
        }

        function decayOneCrumb() {
          let removed = false;
          if (ringSet.size && Math.random() < PROB_BIASED_RING_DECAY) {
            const pick = randomFromSet(ringSet);
            if (pick !== null) {
              weakenCrumbByIndex(pick, 1);
              removed = true;
            }
          }
          if (!removed) {
            const c = (Math.random() * COLS) | 0;
            const r = (Math.random() * ROWS) | 0;
            if (crumbs[idx(c, r)] > 0) weakenCrumb(c, r, 1);
          }
        }

        function randomFromSet(set) {
          const size = set.size;
          if (!size) return null;
          const n = (Math.random() * size) | 0;
          let i = 0;
          for (const v of set) {
            if (i++ === n) return v;
          }
          return null;
        }
        function countCrumbs() {
          let k = 0;
          for (let i = 0; i < N; i++) if (crumbs[i] > 0) k++;
          return k;
        }

        // ====== RENDER ======
        function draw(dt) {
          ctx.clearRect(0, 0, canvas.width / DPR, canvas.height / DPR);
          drawBackgroundGrid();
          drawCrumbs();

          // Draw hole as a vertical slot on the left edge
          drawHole();

          // Mouse
          drawMouseHead(
            player.x,
            player.y + player.r * 0.05,
            player.r,
            player.color
          );
          // Cats
          for (const cat of cats) drawCatHead(cat.x, cat.y, cat.r, cat.color);

          // Debug: first cat path
          if (keys["Shift"] && cats.length && cats[0].path)
            drawPath(cats[0].path);
        }

        function drawHole() {
          const rmin = Math.max(0, hole.r - hole.halfHeight);
          const rmax = Math.min(ROWS - 1, hole.r + hole.halfHeight);
          const y = rmin * TILE;
          const h = (rmax - rmin + 1) * TILE;
          const w = Math.floor(TILE * 1.1);
          ctx.save();
          const g = ctx.createLinearGradient(0, y, w, y);
          g.addColorStop(0, "#000");
          g.addColorStop(1, "#050505");
          ctx.fillStyle = g;
          ctx.fillRect(0, y, w, h);
          ctx.fillStyle = "rgba(255,255,255,0.85)";
          ctx.font = "600 12px system-ui, sans-serif";
          ctx.fillText("Hole", 6, y - 6 < 12 ? 12 : y - 6);
          ctx.restore();
        }

        function drawBackgroundGrid() {
          const w = COLS * TILE,
            h = ROWS * TILE;
          ctx.save();
          const vg = ctx.createRadialGradient(
            w * 0.5,
            h * 0.45,
            Math.min(w, h) * 0.25,
            w * 0.5,
            h * 0.5,
            Math.max(w, h) * 0.68
          );
          vg.addColorStop(0, "rgba(255,255,255,0.02)");
          vg.addColorStop(1, "rgba(0,0,0,0.35)");
          ctx.fillStyle = vg;
          ctx.fillRect(0, 0, w, h);
          ctx.globalAlpha = 0.07;
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 1;
          ctx.beginPath();
          for (let c = 0; c <= COLS; c++) {
            ctx.moveTo(c * TILE, 0);
            ctx.lineTo(c * TILE, h);
          }
          for (let r = 0; r <= ROWS; r++) {
            ctx.moveTo(0, r * TILE);
            ctx.lineTo(w, r * TILE);
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
          ctx.restore();
        }

        function drawCrumbs() {
          ctx.save();
          for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
              if (crumbs[idx(c, r)] > 0) {
                const x = c * TILE,
                  y = r * TILE;
                ctx.fillStyle = getCSS("--crumb");
                ctx.fillRect(x + 3, y + 3, TILE - 6, TILE - 6);
                ctx.fillStyle = getCSS("--crumb2");
                ctx.fillRect(x + 5, y + 5, TILE - 10, TILE - 10);
              }
            }
          }
          ctx.restore();
        }

        // ====== Minimal, geometric heads ======
        function drawMouseHead(x, y, r, color) {
          ctx.save();
          // Head
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
          // Ears (round)
          const er = r * 0.55;
          const ey = y - r * 0.85;
          const ex = r * 0.68;
          ctx.fillStyle = shade(color, 0.08);
          ctx.beginPath();
          ctx.arc(x - ex, ey, er, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x + ex, ey, er, 0, Math.PI * 2);
          ctx.fill();
          // Eyes (larger, higher)
          ctx.fillStyle = "rgba(0,0,0,0.85)";
          ctx.beginPath();
          ctx.arc(x - r * 0.38, y - r * 0.36, r * 0.22, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x + r * 0.38, y - r * 0.36, r * 0.22, 0, Math.PI * 2);
          ctx.fill();
          // Nose (circle, 2Ã— bigger)
          ctx.fillStyle = "rgba(0,0,0,0.7)";
          ctx.beginPath();
          ctx.arc(x, y + r * 0.24, r * 0.08 * 2, 0, Math.PI * 2);
          ctx.fill();
          // Whiskers (thin lines)
          ctx.strokeStyle = "rgba(0,0,0,0.75)";
          ctx.lineWidth = Math.max(1, r * 0.06);
          const wy = y + r * 0.24;
          const wdx = r * 0.65;
          const wgap = r * 0.12;
          for (let i = -1; i <= 1; i++) {
            const off = wy + i * wgap;
            ctx.beginPath();
            ctx.moveTo(x - r * 0.12, off);
            ctx.lineTo(x - wdx, off + i * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + r * 0.12, off);
            ctx.lineTo(x + wdx, off + i * 2);
            ctx.stroke();
          }
          ctx.restore();
        }

        function drawCatHead(x, y, r, color) {
          ctx.save();
          // Head
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
          // Ears (taller, pointy â€” flipped with apex up)
          const earBaseY = y - r * 0.45;
          const earApexY = y - r * 1.7;
          // Left ear triangle
          ctx.beginPath();
          ctx.moveTo(x - r * 0.9, earBaseY);
          ctx.lineTo(x - r * 0.15, earBaseY);
          ctx.lineTo(x - r * 0.55, earApexY);
          ctx.closePath();
          ctx.fill();
          // Right ear triangle
          ctx.beginPath();
          ctx.moveTo(x + r * 0.9, earBaseY);
          ctx.lineTo(x + r * 0.15, earBaseY);
          ctx.lineTo(x + r * 0.55, earApexY);
          ctx.closePath();
          ctx.fill();

          // Eyes (larger, higher slits)
          ctx.fillStyle = "rgba(0,0,0,0.88)";
          ctx.beginPath();
          ctx.ellipse(
            x - r * 0.3,
            y - r * 0.36,
            r * 0.1,
            r * 0.28,
            0,
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(
            x + r * 0.3,
            y - r * 0.36,
            r * 0.1,
            r * 0.28,
            0,
            0,
            Math.PI * 2
          );
          ctx.fill();
          // Nose (circle, 2Ã— bigger)
          ctx.fillStyle = "rgba(0,0,0,0.75)";
          ctx.beginPath();
          ctx.arc(x, y + r * 0.18, r * 0.08 * 2, 0, Math.PI * 2);
          ctx.fill();
          // Whiskers
          ctx.strokeStyle = "rgba(0,0,0,0.85)";
          ctx.lineWidth = Math.max(1, r * 0.06);
          const wy = y + r * 0.18;
          const wdx = r * 0.8;
          const wgap = r * 0.14;
          for (let i = -1; i <= 1; i++) {
            const off = wy + i * wgap;
            ctx.beginPath();
            ctx.moveTo(x - r * 0.15, off);
            ctx.lineTo(x - wdx, off + i * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + r * 0.15, off);
            ctx.lineTo(x + wdx, off + i * 2);
            ctx.stroke();
          }
          ctx.restore();
        }

        function drawPath(cells) {
          if (!cells || !cells.length) return;
          ctx.save();
          ctx.strokeStyle = "rgba(122,162,255,0.75)";
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          let first = true;
          for (const cell of cells) {
            const p = centerOf(cell.c, cell.r);
            if (first) {
              ctx.moveTo(p.x, p.y);
              first = false;
            } else ctx.lineTo(p.x, p.y);
          }
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        }

        function shade(hexOrCSS, amt) {
          const tmp = document.createElement("canvas").getContext("2d");
          tmp.fillStyle = hexOrCSS;
          tmp.fillRect(0, 0, 1, 1);
          const data = tmp.getImageData(0, 0, 1, 1).data;
          const r = data[0] / 255,
            g = data[1] / 255,
            b = data[2] / 255;
          const t = amt < 0 ? 0 : 1,
            p = Math.abs(amt);
          const nr = r + (t - r) * p,
            ng = g + (t - g) * p,
            nb = b + (t - b) * p;
          return `rgb(${(nr * 255) | 0}, ${(ng * 255) | 0}, ${(nb * 255) | 0})`;
        }

        // ====== Basic sanity tests (console) ======
        function runSanityTests() {
          if (!DEBUG) return;
          try {
            // 1) Crumb add/remove/weakening
            const tc = 5,
              tr = 5;
            crumbs[idx(tc, tr)] = 0;
            console.assert(
              !isCrumb(tc, tr),
              "Empty cell should NOT be a crumb"
            );
            addCrumb(tc, tr, 2);
            console.assert(
              isCrumb(tc, tr),
              "After addCrumb, cell SHOULD be a crumb"
            );
            const before = crumbs[idx(tc, tr)];
            weakenCrumb(tc, tr, 1);
            console.assert(
              crumbs[idx(tc, tr)] === Math.max(0, before - 1),
              "weakenCrumb should reduce thickness by 1"
            );
            weakenCrumb(tc, tr, 10);
            console.assert(
              !isCrumb(tc, tr),
              "After enough weakening, cell should clear"
            );

            // 2) Cat slowdown factor (must be >= 3x slower)
            const openSpeed = PLAYER_SPEED_CELLS * TILE;
            const crumbSpeed = PLAYER_SPEED_CELLS * TILE * CAT_SPEED_IN_CRUMB;
            console.assert(
              crumbSpeed <= openSpeed / 3 + 1e-6,
              "Cat must be >=3x slower in crumbs"
            );

            // 3) Grid snapping consistency (vertical movement keeps x centered)
            const col = cellAt(player.x, player.y).c;
            dirX = 0;
            dirY = -1;
            moveAgent(player, 0, -player.speed * 0.016, true);
            // simulate update snapping branch
            const cc = cellAt(player.x, player.y);
            player.x = (cc.c + 0.5) * TILE;
            console.assert(
              Math.abs(player.x - (col + 0.5) * TILE) < 1e-6,
              "Vertical move keeps X centered on column"
            );

            // 4) Key mapping should set wishX/wishY and NOT dirX/dirY
            const prevDirX = dirX,
              prevDirY = dirY;
            setDirectionFromKey("ArrowLeft");
            console.assert(wishX === -1 && wishY === 0, "Left maps to (-1,0)");
            setDirectionFromKey("ArrowRight");
            console.assert(wishX === 1 && wishY === 0, "Right maps to (1,0)");
            setDirectionFromKey("ArrowUp");
            console.assert(wishX === 0 && wishY === -1, "Up maps to (0,-1)");
            setDirectionFromKey("ArrowDown");
            console.assert(wishX === 0 && wishY === 1, "Down maps to (0,1)");
            console.assert(
              dirX === prevDirX && dirY === prevDirY,
              "setDirectionFromKey must not change committed dir"
            );

            // 5) A* trivial case: start==goal returns []
            const pathEmpty = aStar(1, 1, 1, 1);
            console.assert(
              Array.isArray(pathEmpty) && pathEmpty.length === 0,
              "A* start==goal should return empty path"
            );

            // 6) Turn when stopped off-center should snap and commit
            {
              // stop and set off-center
              dirX = 0;
              dirY = 0;
              wishX = 0;
              wishY = -1;
              player.x = 10 * TILE + 0.2 * TILE;
              player.y = 10 * TILE + 0.5 * TILE;
              update(0);
              console.assert(
                dirY === -1 && dirX === 0,
                "Stopped off-center: vertical wish commits"
              );
              const fracX = player.x / TILE - Math.floor(player.x / TILE);
              console.assert(
                Math.abs(fracX - 0.5) < 1e-2,
                "X snapped to column center when starting vertical"
              );
            }

            // 7) Turn while moving horizontally should eventually commit near a center
            {
              // isolate from cats
              cats = [];
              // set state
              dirX = 1;
              dirY = 0;
              wishX = 0;
              wishY = -1;
              player.x = (12 + 0.8) * TILE;
              player.y = (8 + 0.5) * TILE;
              let committed = false;
              for (let t = 0; t < 20 && !committed; t++) {
                update(0.02);
                committed = dirY !== 0;
              }
              console.assert(
                committed,
                "Moving horizontal: vertical turn should commit near a center"
              );
            }

            // 8) Turn while moving vertically should commit near a center
            {
              cats = [];
              dirX = 0;
              dirY = -1;
              wishX = 1;
              wishY = 0;
              player.x = (16 + 0.5) * TILE;
              player.y = (12 + 0.2) * TILE;
              let committed2 = false;
              for (let t = 0; t < 20 && !committed2; t++) {
                update(0.02);
                committed2 = dirX !== 0;
              }
              console.assert(
                committed2,
                "Moving vertical: horizontal turn should commit near a center"
              );
            }

            console.log("%cSanity tests passed", "color:#6cf");
          } catch (e) {
            console.error("Sanity tests failed", e);
          }
        }
      })();
    </script>
  </body>
</html>
